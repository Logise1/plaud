<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grabar Clase - Plaud</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <style>
        .recording-pulse {
            animation: pulse-red 2s infinite;
        }

        @keyframes pulse-red {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                transform: scale(1);
                box-shadow: 0 0 0 20px rgba(239, 68, 68, 0);
            }

            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Estilo para el dropdown negro solicitado */
        select {
            background-color: black !important;
            color: white !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right .7em top 50%;
            background-size: .65em auto;
        }

        select option {
            background-color: black;
            color: white;
        }

        /* Custom Scrollbar for Transcript */
        #overlayTranscript::-webkit-scrollbar {
            width: 6px;
        }

        #overlayTranscript::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        #overlayTranscript::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        /* Animation utilities */
        .animate-in {
            animation-fill-mode: both;
        }

        .fade-in {
            animation-name: fade-in-keyframes;
        }

        .zoom-in-95 {
            animation-name: zoom-in-95-keyframes;
        }

        @keyframes fade-in-keyframes {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes zoom-in-95-keyframes {
            from {
                transform: scale(0.95);
            }

            to {
                transform: scale(1);
            }
        }
    </style>
</head>

<body class="bg-slate-50 text-slate-800 min-h-screen font-sans">

    <!-- Navegación -->
    <nav class="bg-black border-b border-slate-800 shadow-sm sticky top-0 z-50">
        <div class="max-w-4xl mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center gap-2 text-white font-bold text-xl">
                <i class="fas fa-wave-square text-indigo-400"></i>
                <span>Plaud</span>
            </div>
            <a href="ver_resumenes.html" class="text-sm font-medium text-slate-300 hover:text-white transition-colors">
                Ver Resúmenes <i class="fas fa-arrow-right ml-1"></i>
            </a>
        </div>
    </nav>

    <!-- Contenido Principal -->
    <main class="max-w-2xl mx-auto px-4 py-8 space-y-6">

        <div class="text-center space-y-2">
            <h1 class="text-3xl font-bold text-slate-900">Nueva Grabación</h1>
            <p class="text-slate-500">Selecciona la asignatura y comienza a grabar sin límites.</p>
        </div>

        <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 space-y-6">

            <!-- Selector de Asignatura Negro -->
            <div>
                <label class="block text-sm font-medium text-slate-700 mb-2">Asignatura</label>
                <div class="relative">
                    <select id="subjectSelect"
                        class="w-full p-4 rounded-lg border border-slate-800 focus:ring-2 focus:ring-indigo-500 outline-none font-medium text-lg shadow-sm">
                        <option value="">Seleccionar asignatura...</option>
                        <option value="Matemáticas">Matemáticas</option>
                        <option value="Física y Química">Física y Química</option>
                        <option value="Lengua">Lengua</option>
                        <option value="Geografía">Geografía</option>
                        <option value="TIC">TIC</option>
                        <option value="ATE">ATE</option>
                        <option value="EPVA">EPVA</option>
                        <option value="Project">Project</option>
                        <option value="Inglés">Inglés</option>
                        <option value="Educación Física">Educación Física</option>
                        <option value="Tecnología y Digitalización">Tecnología y Digitalización</option>
                        <option value="Otros">Otros</option>
                    </select>
                </div>
            </div>

            <!-- Botón de Grabación y Visualizador -->
            <div class="flex flex-col items-center justify-center py-6 space-y-4">
                <div id="recordContainer" class="relative flex items-center justify-center w-48 h-48">
                    <!-- Visualizador Canvas (detrás del botón) -->
                    <canvas id="visualizer" width="200" height="200"
                        class="absolute top-0 left-0 w-full h-full z-0 opacity-0 transition-opacity duration-300"></canvas>

                    <!-- Anillo de pulso (fallback/decoración) -->
                    <div id="pulseRing" class="absolute w-36 h-36 rounded-full bg-red-400 opacity-20 hidden z-0"></div>

                    <!-- Botón Principal -->
                    <button id="toggleRecordBtn"
                        class="relative z-10 w-28 h-28 rounded-full bg-black text-white shadow-xl flex items-center justify-center transition-all hover:scale-105 border-4 border-slate-100">
                        <i id="micIcon" class="fas fa-microphone text-4xl"></i>
                    </button>
                </div>

                <div class="text-center">
                    <p id="statusText" class="text-xl font-medium text-slate-500">Toca para grabar</p>
                    <p id="timeText" class="text-base text-slate-400 mt-1 font-mono opacity-0">00:00:00</p>
                </div>
            </div>

            <!-- Transcripción en vivo (Limitada a 300 chars visibles) -->
            <div class="bg-slate-50 p-4 rounded-lg border border-slate-200 min-h-[140px] relative">
                <h3 class="text-xs font-bold text-slate-400 uppercase mb-2 flex justify-between items-center">
                    <span>Transcripción en vivo</span>
                    <span class="text-[10px] bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded font-bold">LIVE</span>
                </h3>
                <div class="relative overflow-hidden h-24">
                    <!-- Gradiente superior para efecto de desvanecimiento -->
                    <div class="absolute top-0 left-0 w-full h-8 bg-gradient-to-b from-slate-50 to-transparent z-10">
                    </div>

                    <p id="transcriptText"
                        class="text-slate-600 text-sm leading-relaxed italic break-words absolute bottom-0 w-full">
                        ...esperando audio...
                    </p>
                </div>
                <p class="text-[10px] text-slate-400 text-center mt-2">Se muestran solo las últimas palabras. Todo se
                    está grabando.</p>
            </div>

            <!-- Botón Parar y Procesar -->
            <button id="processBtn" disabled
                class="w-full py-4 bg-slate-200 text-slate-400 rounded-lg font-bold flex items-center justify-center gap-2 transition-all shadow-sm">
                <i class="fas fa-stop-circle"></i>
                <span>Parar y Procesar Clase</span>
            </button>

            <!-- Loader -->
            <div id="loader" class="hidden text-center py-8 bg-indigo-50 rounded-lg border border-indigo-100">
                <i class="fas fa-circle-notch fa-spin text-indigo-600 text-4xl mb-4"></i>
                <h3 class="text-lg font-bold text-indigo-900">Procesando con IA...</h3>
                <p class="text-sm text-indigo-700 mt-2 px-4">Estamos analizando toda la grabación para generar resumen,
                    quiz y flashcards.</p>
            </div>

        </div>
    </main>

    <!-- FULL SCREEN RECORDING OVERLAY -->
    <div id="fullScreenOverlay"
        class="fixed inset-0 bg-black z-[100] hidden flex-col items-center justify-center p-8 transition-opacity duration-500">
        <!-- Header -->
        <div class="absolute top-8 w-full max-w-4xl flex justify-between items-center px-4">
            <div class="flex items-center gap-3">
                <div class="w-3 h-3 rounded-full bg-red-500 animate-pulse"></div>
                <span class="text-red-500 font-bold tracking-widest text-sm">GRABANDO</span>
                <span id="overlayTimeText" class="text-slate-400 font-mono text-sm ml-2">00:00:00</span>
            </div>
            <div class="flex items-center gap-2 text-slate-600 text-xs uppercase font-bold tracking-widest">
                <i class="fas fa-shield-alt"></i> Anti-Exit & WakeLock Mod
            </div>
        </div>

        <!-- Central Transcript -->
        <div class="flex-grow flex items-center justify-center w-full max-w-5xl overflow-hidden relative">
            <!-- Gradientes para desvanecer -->
            <div class="absolute top-0 w-full h-20 bg-gradient-to-b from-black to-transparent z-10"></div>
            <div class="absolute bottom-0 w-full h-20 bg-gradient-to-t from-black to-transparent z-10"></div>

            <div class="relative w-full max-w-5xl h-[60vh] flex flex-col justify-end pb-10">
                <!-- Stats Bar Floating -->
                <div id="overlayStats"
                    class="absolute top-0 right-0 left-0 mx-auto w-fit flex flex-wrap justify-center gap-4 sm:gap-6 p-3 bg-black/40 backdrop-blur-md rounded-full border border-white/10 text-slate-300 font-mono text-xs sm:text-sm transition-all duration-300 z-20">
                    <div class="flex items-center gap-2">
                        <span class="text-slate-500 uppercase tracking-wider text-[10px]">Tiempo</span>
                        <span id="statTime" class="font-bold text-white">00:00</span>
                    </div>
                    <div class="w-px bg-white/10 h-4 self-center"></div>
                    <div class="flex items-center gap-2">
                        <span class="text-slate-500 uppercase tracking-wider text-[10px]">WPM</span>
                        <span id="statWPM" class="font-bold text-indigo-400">0</span>
                    </div>
                    <div class="w-px bg-white/10 h-4 self-center"></div>
                    <div class="flex items-center gap-2">
                        <span class="text-slate-500 uppercase tracking-wider text-[10px]">Palabras</span>
                        <span id="statWords" class="font-bold text-emerald-400">0</span>
                    </div>
                    <div class="w-px bg-white/10 h-4 self-center"></div>
                    <div class="flex items-center gap-2">
                        <span class="text-slate-500 uppercase tracking-wider text-[10px]">Cars</span>
                        <span id="statChars" class="font-bold text-slate-200">0</span>
                    </div>
                </div>

                <div id="overlayTranscript"
                    class="text-3xl md:text-5xl leading-tight text-white font-medium text-center h-full overflow-y-auto flex flex-col justify-end transition-all px-4 pb-12 mask-image-b">
                    <!-- Text will be injected here -->
                    <span class="opacity-50 italic text-2xl">Esperando voz...</span>
                </div>
            </div>
        </div>

        <!-- Button to Stop -->
        <button id="overlayStopBtn"
            class="mb-12 group flex items-center gap-4 bg-slate-900 border border-slate-700 hover:bg-red-900/30 hover:border-red-500/50 text-slate-300 hover:text-red-400 px-8 py-4 rounded-full transition-all duration-300">
            <div class="w-12 h-12 rounded-full border-2 border-current flex items-center justify-center">
                <i class="fas fa-stop text-xl"></i>
            </div>
            <span class="text-lg font-medium">Finalizar Grabación</span>
        </button>
    </div>

    <!-- Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getDatabase, ref, push, set } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- CONFIGURACIÓN FIREBASE (RTDB PÚBLICA) ---
        const firebaseConfig = {
            databaseURL: "https://chatpro-23332-default-rtdb.asia-southeast1.firebasedatabase.app/"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- CONFIGURACIÓN MISTRAL ---
        const MISTRAL_API_KEY = "evxly62Xv91b752fbnHA2I3HD988C5RT";
        const API_ENDPOINT = "https://api.mistral.ai/v1/chat/completions";

        // DOM Elements
        const subjectSelect = document.getElementById('subjectSelect');
        const toggleBtn = document.getElementById('toggleRecordBtn');
        const pulseRing = document.getElementById('pulseRing');
        const micIcon = document.getElementById('micIcon');
        const statusText = document.getElementById('statusText');
        const timeText = document.getElementById('timeText');
        const transcriptDisplay = document.getElementById('transcriptText');
        const processBtn = document.getElementById('processBtn');
        const loader = document.getElementById('loader');

        // Overlay Elements
        const overlay = document.getElementById('fullScreenOverlay');
        const overlayTranscript = document.getElementById('overlayTranscript');
        const overlayTimeText = document.getElementById('overlayTimeText'); // Header time
        const overlayStopBtn = document.getElementById('overlayStopBtn');

        // Stats Elements
        const statTime = document.getElementById('statTime');
        const statWPM = document.getElementById('statWPM');
        const statWords = document.getElementById('statWords');
        const statChars = document.getElementById('statChars');

        overlayStopBtn.onclick = () => {
            // Simulamos click en el botón principal para detener
            toggleBtn.click();
        };

        // State Variables
        let isRecording = false;
        let fullTranscript = '';
        let committedTranscript = '';
        let recognition = null;
        let startTime = null;
        let timerInterval = null;
        let wakeLock = null; // Variable para Wake Lock API
        let recognitionActive = false; // Estado real del motor de reconocimiento
        let watchdogTimer = null; // Timer para revivir el reconocimiento

        // Audio Visualizer Variables
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let canvas = document.getElementById('visualizer');
        let canvasCtx = canvas.getContext('2d');
        let visualizerFrame = null;

        // --- SPEECH RECOGNITION SETUP ---
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true; // Permite grabación continua
            recognition.interimResults = true;
            recognition.lang = 'es-ES';

            recognition.onstart = () => {
                console.log("Speech Recognition: ACTIVO");
                recognitionActive = true;
            };

            recognition.onresult = (event) => {
                let currentSessionFinal = '';
                let interimTranscript = '';

                // Recalculamos todo el texto de la sesión actual para evitar duplicados
                for (let i = 0; i < event.results.length; ++i) {
                    const txt = event.results[i][0].transcript.trim(); // Limpiamos espacios basura
                    if (event.results[i].isFinal) {
                        currentSessionFinal += txt + ' ';
                    } else {
                        interimTranscript += txt + ' ';
                    }
                }

                // Actualizamos el transcript completo con lo confirmado previamente + lo nuevo de esta sesión
                fullTranscript = committedTranscript + currentSessionFinal;

                // --- LÓGICA DE VISUALIZACIÓN LIMITADA (300 CHARS) ---
                const combinedText = fullTranscript + interimTranscript;
                if (combinedText.length > 300) {
                    transcriptDisplay.innerText = "..." + combinedText.slice(-300);
                } else {
                    transcriptDisplay.innerText = combinedText || "...escuchando...";
                }

                // Overlay Update (Efecto Tipo Máquina de Escribir)
                if (combinedText) {
                    // Solo animamos la parte NUEVA de la transcripción
                    let currentDisplayed = overlayTranscript.dataset.fullText || "";

                    // Si hubo un reset/corrección mayor y el texto es más corto, reseteamos visualmente
                    if (combinedText.length < currentDisplayed.length) {
                        overlayTranscript.innerText = combinedText;
                        overlayTranscript.dataset.fullText = combinedText;
                        currentDisplayed = combinedText;
                    }

                    if (combinedText.length > currentDisplayed.length) {
                        // Hay nuevo texto
                        let newPart = combinedText.substring(currentDisplayed.length);

                        // HEURÍSTICA: Si falta espacio visualmente entre palabras, lo forzamos
                        // (Por si el tracking se desfasó o el audio vino pegado)
                        const lastChar = overlayTranscript.innerText.slice(-1);
                        // Verificamos si necesitamos espacio extra (simple check)
                        if (overlayTranscript.innerText.length > 0 &&
                            !/\s/.test(lastChar) &&
                            !/^\s/.test(newPart) &&
                            overlayTranscript.innerText !== "Esperando voz...") {
                            newPart = ' ' + newPart;
                            currentDisplayed += ' ';
                            // No actualizamos dataset aquí para mantener sync pura con fullTranscript, 
                            // pero visualmente lo necesitamos
                        }

                        // WORD BY WORD EFFECT (Instantáneo pero animado)
                        appendWordMark(newPart);

                        // Actualizar puntero de texto mostrado
                        overlayTranscript.dataset.fullText = combinedText;
                    }
                }

                // Actualizar Stats en Tiempo Real
                updateStats(fullTranscript);

                updateProcessButton();
            };

            // Función para añadir texto palabra por palabra con animación
            function appendWordMark(text) {
                if (!text) return;

                // Si es el primer texto real, limpiamos el placeholder
                if (overlayTranscript.innerText.includes("Esperando voz...")) {
                    overlayTranscript.innerHTML = "";
                }

                // Recortar historial visual si es muy largo para rendimiento
                if (overlayTranscript.childElementCount > 100) {
                    // Remover los primeros 10 elementos
                    for (let k = 0; k < 10; k++) {
                        if (overlayTranscript.firstChild) overlayTranscript.removeChild(overlayTranscript.firstChild);
                    }
                }

                // Creamos un span para el nuevo fragmento
                // Si el fragmento trae espacios, intentamos respetar la estructura de palabras
                // Pero lo más simple y robusto es meter el chunk entero en un span con fade-in
                const span = document.createElement('span');
                span.innerText = text;
                span.className = "animate-in fade-in zoom-in-95 duration-300 inline-block"; // Tailwind animate

                overlayTranscript.appendChild(span);

                // Auto-scroll al fondo
                overlayTranscript.scrollTop = overlayTranscript.scrollHeight;
            }

            // --- ESTADÍSTICAS ---
            function updateStats(text) {
                const now = Date.now();
                const diffMs = now - (startTime || now);
                const diffMin = diffMs / 60000;

                // Words
                const words = text ? text.trim().split(/\s+/).length : 0;
                statWords.innerText = words;

                // Chars
                const chars = text ? text.length : 0;
                statChars.innerText = chars;

                // WPM
                // Evitamos división por cero o valores locos al inicio
                if (diffMin > 0.01) {
                    const wpm = Math.round(words / diffMin);
                    statWPM.innerText = wpm;
                } else {
                    statWPM.innerText = "0";
                }
            }

            // --- LÓGICA DE GRABACIÓN INFINITA ---
            // Si el navegador corta la grabación por silencio o tiempo, la reiniciamos inmediatamente
            // --- LÓGICA DE GRABACIÓN INFINITA MEJORADA ---
            recognition.onend = () => {
                console.log("Speech Recognition: END (Se detuvo el motor)");
                recognitionActive = false;

                // Si seguimos 'grabando' (usuario no ha dado click a Parar), reiniciamos
                if (isRecording) {
                    committedTranscript = fullTranscript;
                    // El Watchdog se encargará de revivirlo si onend no lo hace rápido,
                    // pero intentamos reinicio inmediato:
                    try { recognition.start(); } catch (e) { }
                }
            };

            recognition.onerror = (event) => {
                console.warn("Speech Error:", event.error);
                recognitionActive = false; // Asumimos que paró si hubo error

                if (event.error === 'no-speech') {
                    return; // Ignoramos silencios
                }

                // CRÍTICO: No paramos en error de red, dejamos que el Watchdog reintente
                if (event.error === 'network') {
                    console.log("Error de red detectado. Reintentando...");
                    return;
                }

                // Solo paramos fatalmente si es permiso denegado o hardware
                if (event.error === 'not-allowed' || event.error === 'audio-capture') {
                    isRecording = false;
                    stopRecordingSession();
                    alert("Error crítico de micrófono: " + event.error);
                }
            };
        } else {
            alert("Tu navegador no soporta reconocimiento de voz. Por favor usa Google Chrome.");
        }

        // --- TEMPORIZADOR ---
        function startTimer() {
            startTime = Date.now();
            timeText.classList.remove('opacity-0');
            timerInterval = setInterval(() => {
                const diff = Date.now() - startTime;
                const hours = Math.floor(diff / 3600000).toString().padStart(2, '0');
                const minutes = Math.floor((diff % 3600000) / 60000).toString().padStart(2, '0');
                const seconds = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
                const timeStr = `${hours}:${minutes}:${seconds}`;
                timeText.innerText = timeStr;
                overlayTimeText.innerText = timeStr;
                statTime.innerText = `${minutes}:${seconds}`; // Time simple en stats

                // Actualizar WPM cada segundo también, por si el tiempo pasa sin palabras
                updateStats(fullTranscript);
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // --- MANEJO DE GRABACIÓN ---
        toggleBtn.addEventListener('click', () => {
            if (!subjectSelect.value) {
                alert("Por favor selecciona una asignatura primero.");
                return;
            }

            if (isRecording) {
                // El botón principal ahora PAUSA/PARA la sesión para permitir procesar
                stopRecordingSession();
            } else {
                startRecordingSession();
            }
        });

        async function startRecordingSession() {
            try {
                // 1. Iniciar reconocimiento de voz
                recognition.start();

                // 2. Iniciar Visualizador de Audio
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                setupVisualizer(stream);

                isRecording = true;
                // SOLO BORRAMOS SI NO ESTAMOS RECUPERANDO
                if (!fullTranscript) {
                    fullTranscript = '';
                    committedTranscript = '';
                }
                // Si recuperamos, committed debe sincronizarse para que no se duplique
                if (fullTranscript && !committedTranscript) {
                    committedTranscript = fullTranscript;
                }

                transcriptDisplay.innerText = fullTranscript || 'Escuchando...';

                // Iniciar Auto-Save
                startAutoSave();

                // UI Visuals
                toggleBtn.classList.remove('bg-black', 'border-slate-100');
                toggleBtn.classList.add('bg-red-600', 'border-red-200');
                micIcon.classList.remove('fa-microphone');
                micIcon.classList.add('fa-stop');

                canvas.classList.remove('opacity-0');
                pulseRing.classList.add('hidden'); // Usamos canvas ahora

                statusText.innerText = "GRABANDO";
                statusText.classList.add('text-red-600', 'font-bold');

                // ACTIVAR MODO CINE / OSCURO
                overlay.classList.remove('hidden');
                overlay.classList.add('flex');

                // Limpiar texto inicial para que no se pegue "Esperando voz...hola"
                overlayTranscript.innerText = "";
                overlayTranscript.dataset.fullText = "";

                // ACTIVAR PROTECCIONES
                enableWakeLock();
                window.onbeforeunload = (e) => {
                    e.preventDefault();
                    e.returnValue = ''; // Standard anti-exit msg
                };

                // PONIENDO AL perro guardián (WATCHDOG)
                // Chequea cada 2s si el motor murió y lo revive
                if (watchdogTimer) clearInterval(watchdogTimer);
                watchdogTimer = setInterval(() => {
                    if (isRecording && !recognitionActive) {
                        console.log("WATCHDOG: El reconocimiento murió. Reviviéndolo...");
                        try { recognition.start(); } catch (e) { }
                    }
                }, 2000);

                startTimer();
                updateProcessButton();

            } catch (e) {
                console.error("Error al iniciar grabación:", e);
                alert("No se pudo acceder al micrófono. Verifica los permisos.");
            }
        }

        function stopRecordingSession() {
            isRecording = false;
            stopTimer();

            // Detener reconocimiento
            try { recognition.stop(); } catch (e) { }

            // Detener Visualizador y Streams
            if (visualizerFrame) cancelAnimationFrame(visualizerFrame);
            if (audioContext) audioContext.close();
            audioContext = null;
            canvas.classList.add('opacity-0');

            // Limpiar canvas
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

            // UI Visuals
            toggleBtn.classList.add('bg-black', 'border-slate-100');
            toggleBtn.classList.remove('bg-red-600', 'border-red-200');
            micIcon.classList.add('fa-microphone');
            micIcon.classList.remove('fa-stop');

            statusText.innerText = "Grabación detenida";
            statusText.classList.remove('text-red-600', 'font-bold');

            // DESACTIVAR MODO CINE
            overlay.classList.add('hidden');
            overlay.classList.remove('flex');

            // DESACTIVAR PROTECCIONES
            if (wakeLock) wakeLock.release().then(() => wakeLock = null);
            window.onbeforeunload = null;

            // Desactivar Watchdog
            if (watchdogTimer) clearInterval(watchdogTimer);
            if (autoSaveIntervalId) clearInterval(autoSaveIntervalId); // Stop autosave
            watchdogTimer = null;
            recognitionActive = false;

            updateProcessButton();
        }

        // --- WAKE LOCK API ---
        async function enableWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock isActive');

                    // Re-adquirir si se pierde visibilidad
                    document.addEventListener('visibilitychange', async () => {
                        if (wakeLock !== null && document.visibilityState === 'visible') {
                            wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock Re-acquired');
                        }
                    });

                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                }
            }
        }

        // --- SISTEMA DE VISUALIZACIÓN DE AUDIO ---
        // --- AUTO-SAVE & RECOVERY SYSTEM ---
        const AUTO_SAVE_KEY = 'plaud_autosave_v1';
        let autoSaveIntervalId = null;

        function startAutoSave() {
            if (autoSaveIntervalId) clearInterval(autoSaveIntervalId);
            autoSaveIntervalId = setInterval(() => {
                if (isRecording && fullTranscript.length > 10) {
                    saveToLocal();
                }
            }, 60000); // Guardar cada 1 minuto (user pidió "cada pocos minutos")
        }

        function saveToLocal() {
            const data = {
                transcript: fullTranscript,
                subject: subjectSelect.value,
                timestamp: Date.now(),
                durationAdd: (Date.now() - startTime) // Para sumar al recuperar
            };
            localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(data));
            console.log("Auto-saved session.");
        }

        function checkRecovery() {
            const savedRaw = localStorage.getItem(AUTO_SAVE_KEY);
            if (!savedRaw) return;

            try {
                const saved = JSON.parse(savedRaw);
                const now = Date.now();
                const diffMins = (now - saved.timestamp) / 60000;

                // Regla: Menos de 10 mins desde el último guardado
                if (diffMins < 10) {
                    // Mostrar Botón de recuperación
                    showRecoveryUI(saved);
                }
            } catch (e) {
                console.error("Error reading autosave", e);
            }
        }

        function showRecoveryUI(savedData) {
            // Creamos un aviso bonito
            const alertDiv = document.createElement('div');
            alertDiv.className = "fixed bottom-4 right-4 bg-white border-l-4 border-indigo-500 shadow-2xl p-4 rounded-r z-[60] animate-in fade-in slide-in-from-bottom-5 duration-500 flex flex-col gap-2 max-w-sm";
            alertDiv.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <h4 class="font-bold text-slate-800 text-sm">Sesión Encontrada</h4>
                        <p class="text-xs text-slate-500 mt-1">Hay una grabación reciente de <b>${savedData.subject}</b> (${Math.round(savedData.transcript.length / 5)} palabras).</p>
                        <p class="text-[10px] text-slate-400 mt-1">Hace ${Math.floor((Date.now() - savedData.timestamp) / 60000)} minutos</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-slate-400 hover:text-slate-600"><i class="fas fa-times"></i></button>
                </div>
                <button id="recoverBtnAction" class="bg-indigo-600 text-white text-xs font-bold py-2 px-3 rounded hover:bg-indigo-700 transition">
                    Recuperar y Continuar
                </button>
            `;
            document.body.appendChild(alertDiv);

            document.getElementById('recoverBtnAction').onclick = () => {
                // Restaurar estado
                subjectSelect.value = savedData.subject;
                fullTranscript = savedData.transcript;
                committedTranscript = savedData.transcript;

                // Actualizar UI
                transcriptDisplay.innerText = "..." + fullTranscript.slice(-300);
                updateStats(fullTranscript); // de la función anterior
                alertDiv.remove();

                // Limpiar storage para no volver a pedirlo
                // localStorage.removeItem(AUTO_SAVE_KEY); 
                // Mejor NO borrarlo por si recarga de nuevo por error

                alert("Sesión recuperada. Pulsa el micrófono para continuar grabando.");
            };
        }

        // Check on load
        checkRecovery();

        function setupVisualizer(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);

            analyser.fftSize = 64; // Menos barras, más gruesas
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 60; // Radio del circulo base (alrededor del botón)

            function draw() {
                visualizerFrame = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                // Dibujar barras radiales
                const bars = 24; // Número de barras
                const step = (Math.PI * 2) / bars;

                for (let i = 0; i < bars; i++) {
                    // Mapeamos el valor de frecuencia a una altura
                    // Usamos un rango medio de frecucencias para mejor visual
                    const value = dataArray[i] || 0;
                    const barHeight = (value / 255) * 40; // Altura máxima 40px

                    const angle = i * step;

                    // Coordenadas inicio (en el borde del botón)
                    const x1 = centerX + Math.cos(angle) * (radius + 5);
                    const y1 = centerY + Math.sin(angle) * (radius + 5);

                    // Coordenadas fin (hacia afuera)
                    const x2 = centerX + Math.cos(angle) * (radius + 5 + barHeight);
                    const y2 = centerY + Math.sin(angle) * (radius + 5 + barHeight);

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(x1, y1);
                    canvasCtx.lineTo(x2, y2);
                    canvasCtx.lineWidth = 6;
                    canvasCtx.lineCap = 'round';

                    // Color dinámico según amplitud
                    const hue = 0 + (value / 255) * 60; // Rojo a Amarillo/Naranja
                    canvasCtx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
                    canvasCtx.stroke();
                }
            }
            draw();
        }

        function updateProcessButton() {
            // Habilitar botón de procesar si hay texto y NO estamos grabando activamente
            if (fullTranscript.length > 5 && !isRecording) {
                processBtn.disabled = false;
                processBtn.classList.remove('bg-slate-200', 'text-slate-400');
                processBtn.classList.add('bg-black', 'text-white', 'hover:bg-gray-800', 'cursor-pointer');
            } else {
                processBtn.disabled = true;
                processBtn.classList.add('bg-slate-200', 'text-slate-400');
                processBtn.classList.remove('bg-black', 'text-white', 'hover:bg-gray-800', 'cursor-pointer');
            }
        }

        // --- GUARDADO SIMPLE (SIN AI) ---
        processBtn.addEventListener('click', async () => {
            if (!fullTranscript) return;

            processBtn.classList.add('hidden');
            loader.classList.remove('hidden');
            loader.querySelector('h3').innerText = "Guardando grabación...";
            loader.querySelector('p').innerText = "Subiendo audio transcrito a la nube...";

            const subject = subjectSelect.value;
            // Guardamos el texto completo original
            // Nota: fullTranscript ya contiene todo lo necesario gracias al fix anterior

            try {
                // --- GUARDAR EN FIREBASE ---
                const notesRef = ref(db, 'public_notes');
                const newNoteRef = push(notesRef);
                await set(newNoteRef, {
                    subject: subject,
                    transcript: fullTranscript,
                    timestamp: Date.now(),
                    // Stats
                    durationSeconds: Math.floor((Date.now() - startTime) / 1000),
                    wordCount: fullTranscript.trim().split(/\s+/).length,
                    charCount: fullTranscript.length,
                    wpm: parseInt(document.getElementById('statWPM').innerText) || 0,

                    // Inicializamos campos vacíos
                    summary: null,
                    keyPoints: null,
                    flashcards: null,
                    quiz: null
                });

                // Limpiamos el autosave on success save
                localStorage.removeItem(AUTO_SAVE_KEY);

                alert("¡Grabación guardada! Ve a 'Ver Resúmenes' para generar el contenido con IA.");
                window.location.href = "ver_resumenes.html";

            } catch (error) {
                console.error(error);
                alert("Ocurrió un error al guardar: " + error.message);
                loader.classList.add('hidden');
                processBtn.classList.remove('hidden');
            }
        });
    </script>
</body>

</html>